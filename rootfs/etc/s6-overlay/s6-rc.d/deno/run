#!/usr/bin/with-contenv sh
cd /app

# Debug mode: if DEBUG=1, run in foreground with verbose output for development
if [ ! -z "$DEBUG" ] && [ "$DEBUG" -eq 1 ]; then
  echo "[DEBUG] Deno Debug Mode enabled"
  echo "[DEBUG] TASK: $TASK"
  echo "[DEBUG] FILE: $FILE"
  set -x
fi

if [ ! -z "$TASK" ]; then
  [ ! -z "$DENO_LOG" ] && export DENO_LOG
  TASK_ARGS=""
  [ ! -z "$WATCH" ] && [ "$WATCH" -eq 1 ] && TASK_ARGS="--watch"
  exec s6-setuidgid tundra deno task $TASK_ARGS $TASK
elif [ ! -z "$FILE" ]; then
  RUN_ARGS=
  # Lets check if we have permissions
  if [ ! -z $ALLOW_ALL ]; then
    RUN_ARGS="--allow-all"
  else
    if [ ! -z $ALLOW_HRTIME ]; then
      RUN_ARGS="${RUN_ARGS} --allow-hrtime"
    fi
    if [ ! -z $ALLOW_SYS ]; then
      # if value is 1 then its all, if its 0 then no, else its a list of permissions to allow
      if [ $ALLOW_SYS -eq 1 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-sys"
      elif [ $ALLOW_SYS -ne 0 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-sys=${ALLOW_SYS}"
      fi
    fi
    if [ ! -z $ALLOW_ENV ]; then
      if [ $ALLOW_ENV -eq 1 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-env"
      elif [ $ALLOW_ENV -ne 0 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-env=${ALLOW_ENV}"
      fi
    fi
    if [ ! -z $ALLOW_NET ]; then
      if [ $ALLOW_NET -eq 1 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-net"
      elif [ $ALLOW_NET -ne 0 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-net=${ALLOW_NET}"
      fi
    fi
    if [ ! -z $ALLOW_FFI ]; then
      if [ $ALLOW_FFI -eq 1 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-ffi"
      elif [ $ALLOW_FFI -ne 0 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-ffi=${ALLOW_FFI}"
      fi
    fi
    if [ ! -z $ALLOW_RUN ]; then
      if [ $ALLOW_RUN -eq 1 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-run"
      elif [ $ALLOW_RUN -ne 0 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-run=${ALLOW_RUN}"
      fi
    fi
    if [ ! -z $ALLOW_READ ]; then
      if [ $ALLOW_READ -eq 1 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-read"
      elif [ $ALLOW_READ -ne 0 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-read=${ALLOW_READ}"
      fi
    fi
    if [ ! -z $ALLOW_WRITE ]; then
      if [ $ALLOW_WRITE -eq 1 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-write"
      elif [ $ALLOW_WRITE -ne 0 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-write=${ALLOW_WRITE}"
      fi
    fi
    if [ ! -z $DENO_NO_LOCK ]; then
      if [ $DENO_NO_LOCK -eq 1 ]; then
        RUN_ARGS="${RUN_ARGS} --no-lock"
      fi
    fi
    if [ ! -z $UNSTABLE ]; then
      if [ $UNSTABLE -eq 1 ]; then
        # Throw warning that we are using unstable
        echo "Warning: Using unstable features"
        RUN_ARGS="${RUN_ARGS} --unstable"
      elif [ $UNSTABLE -ne 0 ]; then
        # Parse comma-separated unstable features using POSIX sh (no bash-isms)
        for val in $(printf '%s' "$UNSTABLE" | sed 's/,/ /g'); do
          RUN_ARGS="${RUN_ARGS} --unstable-${val}"
        done
      fi
    fi
  fi
  [ ! -z "$DEBUG" ] && echo "[DEBUG] Running with args: $RUN_ARGS $FILE"
  [ ! -z "$DENO_LOG" ] && export DENO_LOG
  WATCH_ARG=""
  [ ! -z "$WATCH" ] && [ "$WATCH" -eq 1 ] && WATCH_ARG="--watch"
  exec s6-setuidgid tundra deno run --no-prompt $WATCH_ARG $RUN_ARGS $FILE
else 
  # No args passed so we run a dummy app
  cat << EOF > /app/app.ts
export {}
console.log('Welcome to Deno ðŸ¦•')
while (true) {
  await new Promise((resolve) => setTimeout(resolve, 1000))
}
EOF
  [ ! -z "$DENO_LOG" ] && export DENO_LOG
  WATCH_ARG=""
  [ ! -z "$WATCH" ] && [ "$WATCH" -eq 1 ] && WATCH_ARG="--watch"
  exec s6-setuidgid tundra deno run --no-prompt $WATCH_ARG /app/app.ts
fi