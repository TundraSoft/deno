#!/usr/bin/with-contenv sh
cd /app

# ============================================================================
# Deno Service Startup Script
# ============================================================================
# This script manages the startup of Deno applications with support for:
# - FILE mode: Run a specific file with permission flags
# - TASK mode: Execute a deno.json task
# - Fallback: Run a minimal demo app if no FILE or TASK specified
#
# Configuration is driven by environment variables:
# - TASK: Run a task from deno.json
# - FILE: Run a file with permission flags
# - DEBUG: Enable verbose output and shell tracing
# - WATCH: Enable file watching mode
# - DENO_LOG: Set Deno logging level
# ============================================================================

# Debug mode: if DEBUG=1, run in foreground with verbose output for development
if [ ! -z "$DEBUG" ] && [ "$DEBUG" -eq 1 ]; then
  echo "[DEBUG] Deno Debug Mode enabled"
  echo "[DEBUG] TASK: $TASK"
  echo "[DEBUG] FILE: $FILE"
  set -x
fi

# TASK mode: Execute a task from deno.json
if [ ! -z "$TASK" ]; then
  # Export DENO_LOG if set (for logging configuration)
  [ ! -z "$DENO_LOG" ] && export DENO_LOG
  # Build watch argument if enabled
  TASK_ARGS=""
  [ ! -z "$WATCH" ] && [ "$WATCH" -eq 1 ] && TASK_ARGS="--watch"
  # Execute task with proper user privileges
  exec s6-setuidgid tundra deno task $TASK_ARGS $TASK

# FILE mode: Execute a file with granular permission flags
elif [ ! -z "$FILE" ]; then
  RUN_ARGS=
  # Build permission flags based on environment variables
  # Each ALLOW_* variable controls a specific permission capability
  if [ ! -z $ALLOW_ALL ]; then
    RUN_ARGS="--allow-all"
  else
    if [ ! -z $ALLOW_HRTIME ]; then
      RUN_ARGS="${RUN_ARGS} --allow-hrtime"
    fi
    if [ ! -z $ALLOW_SYS ]; then
      # if value is 1 then its all, if its 0 then no, else its a list of permissions to allow
      if [ $ALLOW_SYS -eq 1 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-sys"
      elif [ $ALLOW_SYS -ne 0 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-sys=${ALLOW_SYS}"
      fi
    fi
    if [ ! -z $ALLOW_ENV ]; then
      if [ $ALLOW_ENV -eq 1 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-env"
      elif [ $ALLOW_ENV -ne 0 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-env=${ALLOW_ENV}"
      fi
    fi
    if [ ! -z $ALLOW_NET ]; then
      if [ $ALLOW_NET -eq 1 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-net"
      elif [ $ALLOW_NET -ne 0 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-net=${ALLOW_NET}"
      fi
    fi
    if [ ! -z $ALLOW_FFI ]; then
      if [ $ALLOW_FFI -eq 1 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-ffi"
      elif [ $ALLOW_FFI -ne 0 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-ffi=${ALLOW_FFI}"
      fi
    fi
    if [ ! -z $ALLOW_RUN ]; then
      if [ $ALLOW_RUN -eq 1 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-run"
      elif [ $ALLOW_RUN -ne 0 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-run=${ALLOW_RUN}"
      fi
    fi
    if [ ! -z $ALLOW_READ ]; then
      if [ $ALLOW_READ -eq 1 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-read"
      elif [ $ALLOW_READ -ne 0 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-read=${ALLOW_READ}"
      fi
    fi
    if [ ! -z $ALLOW_WRITE ]; then
      if [ $ALLOW_WRITE -eq 1 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-write"
      elif [ $ALLOW_WRITE -ne 0 ]; then
        RUN_ARGS="${RUN_ARGS} --allow-write=${ALLOW_WRITE}"
      fi
    fi
    if [ ! -z $DENO_NO_LOCK ]; then
      if [ $DENO_NO_LOCK -eq 1 ]; then
        RUN_ARGS="${RUN_ARGS} --no-lock"
      fi
    fi
    if [ ! -z $UNSTABLE ]; then
      if [ $UNSTABLE -eq 1 ]; then
        # Throw warning that we are using unstable
        echo "Warning: Using unstable features"
        RUN_ARGS="${RUN_ARGS} --unstable"
      elif [ $UNSTABLE -ne 0 ]; then
        # Parse comma-separated unstable features using POSIX sh (no bash-isms)
        for val in $(printf '%s' "$UNSTABLE" | sed 's/,/ /g'); do
          RUN_ARGS="${RUN_ARGS} --unstable-${val}"
        done
      fi
    fi
  fi
  [ ! -z "$DEBUG" ] && echo "[DEBUG] Running with args: $RUN_ARGS $FILE"
  [ ! -z "$DENO_LOG" ] && export DENO_LOG
  # Build watch argument if enabled
  WATCH_ARG=""
  [ ! -z "$WATCH" ] && [ "$WATCH" -eq 1 ] && WATCH_ARG="--watch"
  # Execute file with compiled permissions and watch settings
  exec s6-setuidgid tundra deno run --no-prompt $WATCH_ARG $RUN_ARGS $FILE

# Fallback mode: No FILE or TASK specified - run minimal demo app
else 
  # Create a simple demo application for testing
  cat << EOF > /app/app.ts
export {}
console.log('Welcome to Deno ðŸ¦•')
while (true) {
  await new Promise((resolve) => setTimeout(resolve, 1000))
}
EOF
  # Export DENO_LOG if set
  [ ! -z "$DENO_LOG" ] && export DENO_LOG
  # Build watch argument if enabled
  WATCH_ARG=""
  [ ! -z "$WATCH" ] && [ "$WATCH" -eq 1 ] && WATCH_ARG="--watch"
  # Execute demo app
  exec s6-setuidgid tundra deno run --no-prompt $WATCH_ARG /app/app.ts
fi